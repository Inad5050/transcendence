server 
{
    listen 80;
    server_name localhost;

    location /api/ #Cualquier URL que empiece por /api/ irá al servicio 'backend'.  
	{
        rewrite ^/api/(.*)$ /$1 break; #Elimina el prefijo /api de la URL antes de pasarla.
        include fastcgi_params;
        fastcgi_param SCRIPT_FILENAME /var/www/html/www/$fastcgi_script_name; #Señala la ruta de entrada a el backend (en el contenedor), $fastcgi_script_name es una variable de Nginx que contiene el nombre del script extraído de la URL
        fastcgi_pass backend:9000;
    }

    location / #Regla para reenviar todo el resto del tráfico al frontend 
	{
        proxy_pass http://frontend:3000; #Le dice a NGINX que actue como proxy inverso y rediriga el tráfico al contenedor del frontend, puerto 3000
		proxy_set_header Upgrade $http_upgrade; #Para WEBSOCKET -> Un cliente inicia una conexión WebSocket pidiendo "actualizar" (upgrade) la conexión HTTP estándar a una conexión persistente. Estas cabeceras transmiten esa solicitud de actualización a través de NGINX hasta el servidor backend.
        proxy_set_header Connection "upgrade"; #Para WEBSOCKET
        proxy_set_header Host $host; #Esta cabecera conserva el nombre de dominio original solicitado por el usuario.
        proxy_set_header X-Real-IP $remote_addr; #Crea una cabecera X-Real-IP que contiene la dirección IP real del usuario.
        proxy_set_header X-Forwarded-For $proxy_add_x_forwarded_for; #Esta cabecera mantiene una lista de todas las direcciones IP por las que ha pasado una petición
        proxy_set_header X-Forwarded-Proto $scheme; #Es común que un usuario se conecte a NGINX por HTTPS (seguro), pero que NGINX se comunique con el backend por HTTP (interno, no cifrado). El backend pensaría erróneamente que la conexión es insegura. Esta cabecera le dice al backend qué protocolo (http o https) usó el cliente original.
    }
}
